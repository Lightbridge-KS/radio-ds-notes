{
  "hash": "a2492084610079a943f5b54bedbf6916",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: NIfTI Basic\n--- \n\n\n\n\n\n::: {.callout-note appearance=\"simple\"}\n**Prompt:** Explain the data structure of NIfTI file.\n:::\n\n## NIfTI Overview\n\nThe **NIfTI file format** (Neuroimaging Informatics Technology Initiative) is primarily used for storing brain imaging data, such as MRI and fMRI scans. It is an evolution of the older **Analyze 7.5 format**, and it addresses many of its limitations by adding more flexibility and metadata related to spatial orientation and timing. \n\nThe NIfTI file format can store 3D or 4D volumes, typically representing neuroimaging datasets. It contains both **image data** and **metadata** in a well-defined structure.\n\n\n\n**A NIfTI file** consists of two primary components:\n\n1. **Header**: Contains metadata describing the image (size, orientation, voxel dimensions, etc.).\n2. **Image Data**: The actual voxel intensity values.\n\n### NIfTI File Variants\n\n- **Single File (`.nii`)**: Both the header and image data are stored in a single file.\n- **Two-File Format (`.hdr/.img`)**: The header and image data are stored in separate files (`.hdr` for the header and `.img` for the image data).\n\n---\n\n### NIfTI Header\n\nThe NIfTI header is a binary structure containing metadata that describes the dimensions and other properties of the image. It is 348 bytes long in the standard NIfTI format and stores the following key fields:\n\n| **Field**           | **Description**                                                                                                                                   |\n|---------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|\n| **sizeof_hdr**      | The size of the header, typically 348 bytes.                                                                                                      |\n| **datatype**        | Specifies the data type (e.g., unsigned char, 16-bit integer, float). This defines how the voxel data is stored in the image section.             |\n| **dim[]**           | Array specifying the dimensions of the image. `dim[0]` is the number of dimensions (usually 3 or 4 for fMRI). `dim[1]`, `dim[2]`, `dim[3]` represent the size of the image in the x, y, and z directions, respectively. |\n| **pixdim[]**        | Array specifying the pixel size or voxel dimensions in each direction. For example, `pixdim[1]` gives the voxel width in the x direction.          |\n| **vox_offset**      | Offset in bytes from the start of the file to the image data. Usually set to 352 bytes to account for the header length.                           |\n| **scl_slope**       | Scale factor to apply to voxel values (used for scaling image intensity).                                                                         |\n| **scl_inter**       | Intercept to apply after scaling voxel values.                                                                                                    |\n| **qform_code**      | Code specifying whether the orientation information is present and what form it takes (affine transformations).                                   |\n| **qoffset_x, qoffset_y, qoffset_z** | These fields specify the x, y, and z offsets for the spatial location of the image (important for spatial alignment).                   |\n| **sform_code**      | Another code that specifies a different affine transformation if needed (more detailed spatial information).                                      |\n| **srow_x, srow_y, srow_z** | These are 4x4 affine transformation matrix rows that provide detailed orientation and spatial information for the image.                       |\n| **intent_code**     | Code specifying the purpose of the image (e.g., statistical parameter maps, Z-scores, etc.).                                                     |\n| **descrip**         | Free text field describing the image (optional).                                                                                                 |\n\n### Example NIfTI Header Fields:\n\n```plaintext\nsizeof_hdr   : 348\ndim[]        : [4, 64, 64, 30, 150]  # 4D dataset: 64x64x30 voxels, 150 time points\npixdim[]     : [1, 2.0, 2.0, 3.0, 2.0]  # Voxel sizes in mm (x=2, y=2, z=3) and temporal resolution\ndatatype     : 16  # 16 corresponds to float32 data type\nqform_code   : 1  # Quaternion-based rotation\nsform_code   : 1  # Affine transform matrix present\nqoffset_x    : -90.0\nqoffset_y    : -126.0\nqoffset_z    : -72.0\ndescrip      : \"fMRI scan\"\n```\n\n### Image Data\n\nThe image data in a NIfTI file immediately follows the header (or resides in a separate `.img` file in the two-file format). It contains the voxel intensity values of the 3D or 4D image. The format and data type of the image data are specified by the `datatype` field in the header.\n\n- **dim[]** array in the header defines the number of dimensions and the size of each dimension\n\n- **datatype** field specifies the type of data stored for each voxel. \n  - For example, in an MRI scan, each voxel may store a floating-point intensity value or an integer corresponding to the gray level.\n\n- **Voxel Data**: These are the raw intensity values stored in an array. If the image is 3D, this array will be 3-dimensional, and if the image is 4D (like in fMRI, where you have multiple time points), the array will be 4-dimensional.\n\n### Example Voxel Data:\n\nFor a 3D MRI scan of dimensions 64x64x30, the image data would contain 64x64x30 voxel intensity values. If the `datatype` is 16 (float32), each voxel would be a 32-bit floating-point number.\n\nIn a 4D fMRI dataset with 150 time points, the image data would contain a 64x64x30x150 array of voxel values.\n\n---\n\n### Affine Transformations (Spatial Orientation)\n\nNIfTI uses affine transformation matrices to handle spatial orientation and alignment of images. The header contains two codes (`qform_code` and `sform_code`) that specify the type of transformation used.\n\n- **Q-form**: Represents the rotation and translation of the image in space using a quaternion-based approach.\n- **S-form**: Represents the affine transformation using a 4x4 matrix, which provides more explicit control over scaling, rotation, shearing, and translation.\n\nThe affine matrix transforms voxel indices into real-world spatial coordinates (e.g., mm in the scanner space).\n\n### 4x4 Affine Matrix Example:\n\n```\n| srow_x[0] srow_x[1] srow_x[2] qoffset_x |\n| srow_y[0] srow_y[1] srow_y[2] qoffset_y |\n| srow_z[0] srow_z[1] srow_z[2] qoffset_z |\n| 0        0        0        1           |\n```\n\nThis matrix describes how voxel indices map to real-world spatial coordinates, which is important for proper alignment and visualization of images.\n\n---\n\n### NIfTI File Example\n\nFor a **.nii** file (single-file format), you would have:\n\n1. **Header** (348 bytes or more, depending on metadata size).\n2. **Image Data**: Directly following the header, containing the voxel intensity values.\n\nFor a **.hdr/.img** file pair (two-file format):\n\n- **.hdr file**: Contains the header.\n- **.img file**: Contains the image data.\n\n---\n\n### Conclusion\n\n- The **NIfTI header** provides crucial metadata that defines the image’s dimensions, data type, spatial orientation, and voxel sizes.\n- The **image data** is a multidimensional array of voxel intensity values.\n- **Affine transformations** in the header provide spatial alignment information.\n\n## NIfTI Python\n\n::: {.callout-note appearance=\"simple\"}\n**Prompt:** Give example of NIfTI file represented in Python data structure. \n:::\n\nHere’s an example of how a NIfTI file's structure can be represented in Python using a combination of dictionaries and NumPy arrays. The header information is typically stored as a dictionary-like structure, while the image data is stored as a NumPy array.\n\nFirst, let’s assume you’ve loaded a NIfTI file using the popular [**Nibabel**](https://nipy.org/nibabel/) library, which is commonly used in Python for working with NIfTI files.\n\n### Python Code to Load a NIfTI File\n\n::: {#7dddeb23 .cell execution_count=1}\n``` {.python .cell-code}\nfrom pyhere import here\nimport nibabel as nib\nimport numpy as np\n```\n:::\n\n\n::: {#46162869 .cell execution_count=2}\n``` {.python .cell-code}\n# Load the NIfTI file\nnifti_image = nib.load(here(\"data/nifti/avg152T1_LR_nifti.nii\"))\nprint(nifti_image.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(91, 109, 91)\n```\n:::\n:::\n\n\n::: {#9eb728e4 .cell execution_count=3}\n``` {.python .cell-code}\n# Extract header and image data\nheader = nifti_image.header\n\n# This returns the image data as a NumPy array\nimage_data = nifti_image.get_fdata()  \n```\n:::\n\n\n### NIfTI File Header in Python\n\nThe header can be thought of as a dictionary-like object with key-value pairs that describe the image’s metadata:\n\n::: {#4c9a7112 .cell execution_count=4}\n``` {.python .cell-code}\n# Example of NIfTI header represented as a dictionary-like object in Python\nnifti_header = {\n    'sizeof_hdr': header['sizeof_hdr'],  # Size of the header\n    'datatype': header['datatype'],  # Data type of the voxel values\n    'dim': header['dim'],  # Dimensions of the image\n    'pixdim': header['pixdim'],  # Voxel dimensions\n    'qform_code': header['qform_code'],  # Code describing the q-form transformation\n    'sform_code': header['sform_code'],  # Code describing the s-form transformation\n    'srow_x': header['srow_x'],  # Row for the x affine transformation\n    'srow_y': header['srow_y'],  # Row for the y affine transformation\n    'srow_z': header['srow_z'],  # Row for the z affine transformation\n    'vox_offset': header['vox_offset'],  # Offset where the voxel data starts\n    'scl_slope': header['scl_slope'],  # Slope to scale the voxel values\n    'scl_inter': header['scl_inter'],  # Intercept to scale the voxel values\n    'descrip': header['descrip'],  # Description of the image\n    'xyzt_units': header['xyzt_units'],  # Units of measurement for space and time\n}\n```\n:::\n\n\n### Example of the Header Structure:\n\n::: {#e735f07d .cell execution_count=5}\n``` {.python .cell-code}\nnifti_header = {\n    'sizeof_hdr': 348,\n    'datatype': 16,  # float32 data type\n    'dim': [3, 64, 64, 30, 1],  # 3D image: 64x64x30 voxels\n    'pixdim': [1.0, 2.0, 2.0, 3.0, 1.0],  # Voxel dimensions (x=2mm, y=2mm, z=3mm)\n    'qform_code': 1,  # Quaternion-based transformation\n    'sform_code': 1,  # Affine transformation matrix present\n    'srow_x': [-2.0, 0.0, 0.0, 90.0],  # Affine matrix first row\n    'srow_y': [0.0, 2.0, 0.0, -126.0],  # Affine matrix second row\n    'srow_z': [0.0, 0.0, 3.0, -72.0],  # Affine matrix third row\n    'vox_offset': 352,  # Offset where voxel data starts\n    'scl_slope': 1.0,  # Scaling slope for voxel values\n    'scl_inter': 0.0,  # Scaling intercept for voxel values\n    'descrip': \"Sample MRI scan\",  # Descriptive text\n    'xyzt_units': 10  # Millimeters for spatial units\n}\n```\n:::\n\n\n### NIfTI Image Data Representation\n\nThe image data is typically a multidimensional NumPy array that contains the voxel intensity values. In a 3D MRI scan, for example, this could be a 3D array where each element represents the intensity of a voxel.\n\n::: {#2e1befbd .cell execution_count=6}\n``` {.python .cell-code}\n# Example: 64x64x30 3D image data\nimage_data = np.random.rand(64, 64, 30)  # Random data to represent voxel intensities\n\n# Alternatively, you can extract the actual data from the NIfTI object\nimage_data = nifti_image.get_fdata()\n```\n:::\n\n\n### Affine Transformation Matrix\n\nThe affine matrix is a 4x4 transformation matrix stored in the header. This matrix helps map voxel indices to real-world coordinates (such as millimeters in the scanner space).\n\n::: {#a20db4bf .cell execution_count=7}\n``` {.python .cell-code}\n# Extract the affine transformation matrix\naffine_matrix = nifti_image.affine\n```\n:::\n\n\n### Example of the Affine Matrix:\n\n::: {#2a12ad10 .cell execution_count=8}\n``` {.python .cell-code}\naffine_matrix = np.array([\n    [-2.0,  0.0,  0.0,  90.0],\n    [ 0.0,  2.0,  0.0, -126.0],\n    [ 0.0,  0.0,  3.0,  -72.0],\n    [ 0.0,  0.0,  0.0,   1.0]\n])\n```\n:::\n\n\nThis matrix helps map the voxel coordinates in the NIfTI image to real-world coordinates in the scanner’s space.\n\n### Complete Python Representation of a NIfTI File\n\n```python\n# Header as a Python dictionary\nnifti_header = {\n    'sizeof_hdr': 348,\n    'datatype': 16,\n    'dim': [3, 64, 64, 30, 1],\n    'pixdim': [1.0, 2.0, 2.0, 3.0, 1.0],\n    'qform_code': 1,\n    'sform_code': 1,\n    'srow_x': [-2.0, 0.0, 0.0, 90.0],\n    'srow_y': [0.0, 2.0, 0.0, -126.0],\n    'srow_z': [0.0, 0.0, 3.0, -72.0],\n    'vox_offset': 352,\n    'scl_slope': 1.0,\n    'scl_inter': 0.0,\n    'descrip': \"Sample MRI scan\",\n    'xyzt_units': 10\n}\n\n# Image data as a NumPy array (64x64x30)\nimage_data = np.random.rand(64, 64, 30)\n\n# Affine transformation matrix (4x4)\naffine_matrix = np.array([\n    [-2.0,  0.0,  0.0,  90.0],\n    [ 0.0,  2.0,  0.0, -126.0],\n    [ 0.0,  0.0,  3.0,  -72.0],\n    [ 0.0,  0.0,  0.0,   1.0]\n])\n```\n\n### Explanation:\n\n1. **Header**: Contains metadata about the image such as dimensions, data type, voxel sizes, and spatial transformation.\n2. **Image Data**: A 3D array of voxel intensity values, where each value corresponds to a voxel in the brain scan.\n3. **Affine Matrix**: Describes how to map voxel indices to real-world spatial coordinates.\n\nThis structure provides a clear separation of metadata and actual image data, making it easier to handle in research and clinical settings.\n\n",
    "supporting": [
      "nifti_files"
    ],
    "filters": [],
    "includes": {}
  }
}