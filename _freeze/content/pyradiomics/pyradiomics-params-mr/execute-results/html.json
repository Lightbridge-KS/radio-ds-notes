{
  "hash": "556bf3bcd981ecb7a6047cc321cdf0cc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: MRI Parameters\ncode-fold: true\n---\n\n\n\n\n\n\n\n## Thin-slice MRI Radiomics (3 mm)\n\n- [exampleMR_3mm.yaml](https://github.com/AIM-Harvard/pyradiomics/blob/master/examples/exampleSettings/exampleMR_3mm.yaml)\n\nThe **`exampleMR_3mm.yaml`** configuration file is tailored for **thin-slice MRI scans** (~3 mm slice thickness). Thin slices offer better spatial resolution and are particularly useful for detecting fine anatomical details, but they also introduce considerations for radiomics analysis. Below, I’ll explain why this setting is appropriate for such data.\n\n\n\n### `imageType`\n\n```yaml\nimageType:\n  Original: {}\n  LoG:\n    sigma: [2.0, 3.0, 4.0, 5.0]\n  Wavelet: {}\n```\n\n- **`Original`:** Features are extracted directly from the unfiltered image, capturing raw intensity and texture information.\n- **`LoG` (Laplacian of Gaussian):**\n  - Highlights edges and regions with specific spatial scales, determined by `sigma` values.\n  - **Thin slices:** Sigma values ≥ 2 mm are appropriate to avoid noise sensitivity at very fine scales. \n  - Larger sigma values (e.g., 4.0, 5.0) capture coarser textures, which can be useful for thin slices with isotropic voxels.\n- **`Wavelet`:** Decomposes the image into multi-frequency components, capturing texture at multiple scales.\n\n\n### `featureClass`\n\n```yaml\nfeatureClass:\n  shape:\n  firstorder:\n  glcm:\n    - 'Autocorrelation'\n    - 'ClusterProminence'\n    - ... (remaining GLCM features)\n  glrlm:\n  glszm:\n  gldm:\n```\n\n- **Included Feature Classes:**\n  - **`shape`:** Extracts 3D geometric features such as volume, surface area, compactness, and sphericity.\n  - **`firstorder`:** Basic intensity statistics (mean, median, skewness, etc.), critical for characterizing signal distributions in MR data.\n  - **`glcm`:** Gray Level Co-occurrence Matrix for texture features, with a custom list of relevant features enabled (e.g., `Contrast`, `Correlation`).\n  - **`glrlm`, `glszm`, `gldm`:** Additional texture-based feature classes for advanced heterogeneity analysis.\n\n- **Exclusions:**\n  - The `SumAverage` GLCM feature is excluded due to redundancy with other intensity-related features.\n\n\n### `setting: normalize`\n\n\n```yaml\n  normalize: true\n  normalizeScale: 100\n```\n\n- **Why Normalize for MRI?**\n  - MRI intensity values are relative and vary by scanner, vendor, and protocol. Normalization ensures consistency across scans.\n  - **Thin slices:** Often have higher intensity variability within a region due to better spatial resolution, making normalization even more critical.\n- **Normalization Scale (`normalizeScale`):**\n  - Rescales normalized values to a range suitable for radiomics calculations (e.g., ~[0, 100]).\n\n\n### `setting: resampledPixelSpacing`\n\n\n```yaml\n  resampledPixelSpacing: [2, 2, 2]\n```\n\n- **Why Resample?**\n  - Ensures isotropic voxels (uniform resolution in all directions) for consistent feature extraction.\n  - Thin slices (e.g., ~3 mm) typically have anisotropic voxels where the in-plane resolution is finer than the slice thickness.\n  - Resampling to **[2, 2, 2] mm** balances computational efficiency with spatial detail:\n    - Coarser resampling (e.g., [2, 2, 2]) reduces noise and ensures stability for texture features.\n    - Avoids overly fine resampling (e.g., [1, 1, 1]), which could introduce artifacts or excessive computational load.\n\n\n\n### `setting: binWidth`\n\n```yaml\n  binWidth: 5\n```\n- **Why Bin Width Matters:**\n  - Texture features (e.g., GLCM, GLRL) rely on discretizing intensity values into bins.\n  - The choice of bin width affects sensitivity to small intensity differences and the stability of extracted features.\n  - **Bin Width = 5**:\n    - Appropriate for MRI datasets with thin slices, where intensity ranges are typically smaller than CT data.\n    - Results in a manageable number of bins (~16–128), improving the stability and interpretability of texture features.\n\n---\n\n### `setting: voxelArrayShift`\n\n```yaml\n  voxelArrayShift: 300\n```\n\n- **Purpose:**\n  - Shifts voxel intensities by 300 to make most values positive after normalization (mean-centered normalization can produce negative values).\n  - Ensures numerical stability for feature extraction.\n- **Why It’s Important for MRI:**\n  - Thin-slice MRI often has a wider intensity distribution due to finer spatial detail, so the shift prevents issues with negative voxel values.\n\n\n\n### `setting: interpolator`\n\n```yaml\n  interpolator: 'sitkBSpline'\n```\n\n- **`sitkBSpline` (interpolation):**\n  - Smooths voxel intensities during resampling to preserve detail without introducing artifacts.\n  - Works well with the inherently smooth nature of MRI data.\n\n\n\n### Other Notes\n\n- **GLCM Feature Selection:** Disabling redundant features like `SumAverage` ensures computational efficiency and avoids feature redundancy.\n- **Resampling Trade-Offs:**\n  - Resampling to [2, 2, 2] sacrifices some detail but ensures robust feature calculation, which is critical for thin slices with high resolution.\n\n\n### Why It’s Appropriate for Thin-Slice MRI\n\n1. **Normalization**: Accounts for scanner variability and relative MRI intensities.\n2. **Resampling**: Reduces the effect of anisotropy while preserving sufficient detail for texture analysis.\n3. **Feature Selection**: Focuses on features that leverage the higher resolution of thin slices (e.g., texture, shape).\n4. **Bin Width and Shift**: Optimized for MRI intensity ranges and ensures numerical stability.\n5. **LoG Filtering**: Emphasizes spatial details at multiple scales, appropriate for high-resolution data.\n\n## Thick-slice MRI Radiomics (5 mm)\n\n- [exampleMR_5mm.yaml](https://github.com/AIM-Harvard/pyradiomics/blob/master/examples/exampleSettings/exampleMR_5mm.yaml)\n\n\n\n\n\n\n\n```{yaml}\n#| code-fold: true\n\n# This is an example of settings that can be used as a starting point for analyzing MR data with large(r) (~5mm) slice\n# thickness. This is only intended as a starting point and is not likely to be the optimal settings for your dataset.\n# Some points in determining better values are added as comments where appropriate\n\n# When adapting and using these settings for an analysis, be sure to add the PyRadiomics version used to allow you to\n# easily recreate your extraction at a later timepoint:\n\n# #############################  Extracted using PyRadiomics version: <version>  ######################################\n\nimageType:\n  Original: {}\n  LoG:\n    # Because of resampling to (3, 3, 3), the use of sigmas < 3 mm is not recommended.\n    sigma: [3.0, 5.0]\n  Wavelet: {}\n\nfeatureClass:\n  # redundant Compactness 1, Compactness 2 an Spherical Disproportion features are disabled by default, they can be\n  # enabled by specifying individual feature names (as is done for glcm) and including them in the list.\n  shape:\n  firstorder:\n  glcm:  # Disable SumAverage by specifying all other GLCM features available\n    - 'Autocorrelation'\n    - 'JointAverage'\n    - 'ClusterProminence'\n    - 'ClusterShade'\n    - 'ClusterTendency'\n    - 'Contrast'\n    - 'Correlation'\n    - 'DifferenceAverage'\n    - 'DifferenceEntropy'\n    - 'DifferenceVariance'\n    - 'JointEnergy'\n    - 'JointEntropy'\n    - 'Imc1'\n    - 'Imc2'\n    - 'Idm'\n    - 'Idmn'\n    - 'Id'\n    - 'Idn'\n    - 'InverseVariance'\n    - 'MaximumProbability'\n    - 'SumEntropy'\n    - 'SumSquares'\n  glrlm:\n  glszm:\n  gldm:\n\nsetting:\n  # Normalization:\n  # MR signal is usually relative, with large differences between scanners and vendors. By normalizing the image before\n  # feature calculation, this confounding effect may be reduced. However, if only one specific scanner is used, or the\n  # images reflect some absolute world value (e.g. ADC maps, T2maps (NOT T2 weighted)), consider disabling the\n  # normalization.\n  normalize: true\n  normalizeScale: 100  # This allows you to use more or less the same bin width.\n\n  # Resampling:\n  # Increasing the resampled spacing forces PyRadiomics to look at more coarse textures, which may or\n  # may not increase accuracy and stability of your extracted features. Using a small spacing in large slices generates\n  # many interpolated voxels, potentially 'masking' the signal contained in the image.\n  interpolator: 'sitkBSpline'\n  resampledPixelSpacing: [3, 3, 3]\n\n  # Mask validation:\n  # correctMask and geometryTolerance are not needed, as both image and mask are resampled, if you expect very small\n  # masks, consider to enable a size constraint by uncommenting settings below:\n  #minimumROIDimensions: 2\n  #minimumROISize: 50\n\n  # Image discretization:\n  # The ideal number of bins is somewhere in the order of 16-128 bins. A possible way to define a good binwidt is to\n  # extract firstorder:Range from the dataset to analyze, and choose a binwidth so, that range/binwidth remains approximately\n  # in this range of bins.\n  binWidth: 5\n\n  # first order specific settings:\n  # When normalizing, gray values below the mean will be negative. Shifting by 300 (3 StdDevs * 100) ensures that the\n  # majority of voxels is positive (only outliers >3 SD lower than the mean will be negative).\n  voxelArrayShift: 300\n\n  # Misc:\n  # default label value. Labels can also be defined in the call to featureextractor.execute, as a commandline argument,\n  # or in a column \"Label\" in the input csv (batchprocessing)\n  label: 1\n```\n\n",
    "supporting": [
      "pyradiomics-params-mr_files"
    ],
    "filters": [],
    "includes": {}
  }
}